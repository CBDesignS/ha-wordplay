<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H.A WordPlay - DIAGNOSTIC VERSION</title>
    <style>
        /* Same CSS as before - keeping it identical for consistency */
        :root {
            --primary-color: #03a9f4;
            --primary-background-color: #fafafa;
            --secondary-background-color: #e5e5e5;
            --text-primary-color: #212121;
            --text-secondary-color: #727272;
            --divider-color: #e0e0e0;
            --accent-color: #ff9800;
            
            --tile-correct: #4caf50;
            --tile-partial: #ff9800;
            --tile-absent: #9e9e9e;
            --tile-empty: #ffffff;
            --tile-border: #d1d5db;
            --tile-current: #e3f2fd;
            
            --card-margin: 16px;
            --tile-gap: 4px;
            --tile-size: 60px;
        }

        * { box-sizing: border-box; }

        body {
            font-family: Roboto, sans-serif;
            background: var(--primary-background-color);
            margin: 0;
            padding: 20px;
            color: var(--text-primary-color);
        }

        .wordplay-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .connection-status {
            padding: 8px 16px;
            background: #4caf50;
            color: white;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .connection-status.disconnected { background: #f44336; }
        .connection-status.connecting { background: #ff9800; }

        .wordplay-card {
            padding: var(--card-margin);
            min-height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }

        .game-header { text-align: center; margin-bottom: 8px; }

        .game-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--text-primary-color);
            margin: 0;
        }

        .game-status {
            font-size: 14px;
            color: var(--text-secondary-color);
            margin: 4px 0 0 0;
            min-height: 20px;
            transition: all 0.3s ease;
        }

        .game-status.loading { color: var(--primary-color); font-weight: bold; }
        .game-status.success { color: #4caf50; font-weight: bold; }
        .game-status.error { color: #f44336; font-weight: bold; }

        .game-grid {
            display: grid;
            gap: var(--tile-gap);
            justify-content: center;
            margin: 16px 0;
            transition: all 0.3s ease;
        }

        .game-tile {
            width: var(--tile-size);
            height: var(--tile-size);
            border: 2px solid var(--tile-border);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            text-transform: uppercase;
            background: var(--tile-empty);
            transition: all 0.3s ease;
        }

        .game-tile.filled { background: var(--secondary-background-color); border-color: var(--text-secondary-color); }
        .game-tile.correct { background: var(--tile-correct); color: white; border-color: var(--tile-correct); }
        .game-tile.partial { background: var(--tile-partial); color: white; border-color: var(--tile-partial); }
        .game-tile.absent { background: var(--tile-absent); color: white; border-color: var(--tile-absent); }

        .word-length-controls { margin-bottom: 16px; text-align: center; }
        .word-length-selector { margin: 8px; }

        .word-length-selector button {
            margin: 0 4px;
            padding: 8px 16px;
            border: 2px solid var(--primary-color);
            background: white;
            color: var(--primary-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .word-length-selector button.active { background: var(--primary-color); color: white; }
        .word-length-selector button:disabled { opacity: 0.6; cursor: not-allowed; }

        .game-input { width: 100%; max-width: 400px; text-align: center; }

        .input-field {
            width: 100%;
            padding: 12px;
            font-size: 18px;
            text-align: center;
            text-transform: uppercase;
            border: 2px solid var(--tile-border);
            border-radius: 4px;
            margin-bottom: 12px;
            background: white;
            transition: all 0.3s ease;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(3, 169, 244, 0.2);
        }

        .action-buttons { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }

        .action-button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 100px;
        }

        .action-button.primary { background: var(--primary-color); color: white; }
        .action-button.secondary { background: var(--secondary-background-color); color: var(--text-primary-color); }
        .action-button:disabled { opacity: 0.6; cursor: not-allowed; }

        .game-info {
            text-align: center;
            margin-top: 16px;
            padding: 12px;
            background: var(--secondary-background-color);
            border-radius: 4px;
            max-width: 400px;
        }

        .hint-text { font-style: italic; color: var(--text-secondary-color); margin: 8px 0; }

        .debug-info {
            margin-top: 16px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 4px;
            font-size: 12px;
            color: #666;
            text-align: left;
            max-width: 400px;
            max-height: 200px;
            overflow-y: auto;
        }

        .debug-info.error { background: #ffebee; color: #c62828; }
        .debug-info.success { background: #e8f5e8; color: #2e7d32; }

        /* DIAGNOSTIC STYLES */
        .diagnostic-panel {
            margin-top: 16px;
            padding: 12px;
            background: #1e1e1e;
            color: #00ff00;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            max-height: 300px;
            overflow-y: auto;
            text-align: left;
        }

        .diagnostic-panel h4 { color: #ffff00; margin: 0 0 8px 0; }
        .diagnostic-panel .error { color: #ff6666; }
        .diagnostic-panel .success { color: #66ff66; }
        .diagnostic-panel .warning { color: #ffaa00; }
    </style>
</head>
<body>
    <div class="wordplay-container">
        <div class="connection-status" id="connectionStatus">
            üîó DIAGNOSTIC MODE - Connecting...
        </div>

        <div class="wordplay-card">
            <div class="game-header">
                <h1 class="game-title">üîß H.A WordPlay - DIAGNOSTIC</h1>
                <p class="game-status" id="gameStatus">DIAGNOSTIC MODE - Analyzing...</p>
            </div>

            <div class="word-length-controls">
                <div class="word-length-selector">
                    <span>Word Length:</span>
                    <button id="length5" class="active" onclick="diagnosticAction('changeLength', 5)">5</button>
                    <button id="length6" onclick="diagnosticAction('changeLength', 6)">6</button>
                    <button id="length7" onclick="diagnosticAction('changeLength', 7)">7</button>
                    <button id="length8" onclick="diagnosticAction('changeLength', 8)">8</button>
                </div>
            </div>

            <div class="game-grid" id="gameGrid">
                <!-- Grid tiles will be generated by JavaScript -->
            </div>

            <div class="game-input">
                <input type="text" class="input-field" placeholder="DIAGNOSTIC INPUT..." 
                       maxlength="5" id="guessInput" oninput="diagnosticInput()" onkeypress="diagnosticKeyPress(event)">
                
                <div class="action-buttons">
                    <button class="action-button primary" id="submitBtn" onclick="diagnosticAction('submit')">DIAG SUBMIT</button>
                    <button class="action-button secondary" id="hintBtn" onclick="diagnosticAction('hint')">DIAG HINT</button>
                    <button class="action-button secondary" id="newGameBtn" onclick="diagnosticAction('newGame')">DIAG NEW GAME</button>
                </div>
            </div>

            <div class="game-info">
                <div class="hint-text" id="hintText">üîß DIAGNOSTIC MODE ACTIVE</div>
                <p><strong>Diagnostic Version:</strong> Logging all actions and data</p>
                
                <div class="debug-info" id="debugInfo">
                    DIAGNOSTIC LOADING...
                </div>

                <div class="diagnostic-panel" id="diagnosticPanel">
                    <h4>üîç REAL-TIME DIAGNOSTIC LOG</h4>
                    <div id="diagnosticLog">Starting diagnostic mode...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DIAGNOSTIC VARIABLES
        let diagnosticLog = [];
        let currentWordLength = 5;
        let gameGrid = [];
        let accessToken = null;
        let authMethod = 'unknown';
        let lastEntityData = {};
        let actionCount = 0;

        // Current game data
        let currentGameData = {
            word_length: 5,
            game_state: 'idle',
            guesses: [],
            guess_results: [],
            hint: '',
            last_message: '',
            message_type: ''
        };

        // üîç DIAGNOSTIC LOGGING SYSTEM
        function diagLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
            
            diagnosticLog.push(logEntry);
            
            // Keep only last 50 entries
            if (diagnosticLog.length > 50) {
                diagnosticLog = diagnosticLog.slice(-50);
            }
            
            updateDiagnosticDisplay();
            console.log(`üîß DIAG: ${logEntry}`);
        }

        function updateDiagnosticDisplay() {
            const logEl = document.getElementById('diagnosticLog');
            if (logEl) {
                logEl.innerHTML = diagnosticLog.map(entry => {
                    let className = '';
                    if (entry.includes('ERROR:')) className = 'error';
                    else if (entry.includes('SUCCESS:')) className = 'success';
                    else if (entry.includes('WARNING:')) className = 'warning';
                    
                    return `<div class="${className}">${entry}</div>`;
                }).join('');
                
                logEl.scrollTop = logEl.scrollHeight;
            }
        }

        // üîß AUTH DISCOVERY
        function getAccessToken() {
            diagLog('Starting auth discovery...');
            
            try {
                const haTokens = localStorage.getItem('hassTokens');
                if (haTokens) {
                    const tokens = JSON.parse(haTokens);
                    if (tokens.access_token) {
                        authMethod = 'localStorage-hassTokens';
                        diagLog(`Auth found: ${authMethod}`, 'success');
                        return tokens.access_token;
                    }
                }
            } catch (e) {
                diagLog(`Auth method 1 failed: ${e.message}`, 'warning');
            }

            try {
                const sessionAuth = sessionStorage.getItem('hass_auth');
                if (sessionAuth) {
                    const auth = JSON.parse(sessionAuth);
                    if (auth.access_token) {
                        authMethod = 'sessionStorage-hass_auth';
                        diagLog(`Auth found: ${authMethod}`, 'success');
                        return auth.access_token;
                    }
                }
            } catch (e) {
                diagLog(`Auth method 2 failed: ${e.message}`, 'warning');
            }

            authMethod = 'no-auth-found';
            diagLog('No auth token found - attempting without auth', 'warning');
            return null;
        }

        // üîç DIAGNOSTIC API CALLS
        async function diagnosticApiCall(url, options = {}) {
            diagLog(`API CALL: ${url}`);
            
            try {
                const headers = {'Content-Type': 'application/json'};
                
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                    diagLog('Using auth token for API call');
                } else {
                    diagLog('No auth token - attempting without auth', 'warning');
                }
                
                const response = await fetch(url, {
                    method: options.method || 'GET',
                    headers: headers,
                    body: options.body ? JSON.stringify(options.body) : undefined
                });
                
                diagLog(`API Response: ${response.status} ${response.statusText}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                diagLog(`API Data received: ${JSON.stringify(data).substring(0, 100)}...`);
                
                return data;
                
            } catch (error) {
                diagLog(`API ERROR: ${error.message}`, 'error');
                throw error;
            }
        }

        // üîç DIAGNOSTIC GAME STATE REFRESH
        async function diagnosticRefreshGameState() {
            diagLog('=== REFRESHING GAME STATE ===');
            
            try {
                // Get game state sensor
                const gameStateData = await diagnosticApiCall('/api/states/sensor.ha_wordplay_game_state');
                diagLog(`Game State Entity: ${JSON.stringify(gameStateData, null, 2)}`);
                lastEntityData.gameState = gameStateData;
                
                // Get input entity
                const inputData = await diagnosticApiCall('/api/states/text.ha_wordplay_guess_input');
                diagLog(`Input Entity: ${JSON.stringify(inputData, null, 2)}`);
                lastEntityData.input = inputData;
                
                // Get word length entity
                const lengthData = await diagnosticApiCall('/api/states/select.ha_wordplay_word_length');
                diagLog(`Length Entity: ${JSON.stringify(lengthData, null, 2)}`);
                lastEntityData.length = lengthData;
                
                // Parse game state
                if (gameStateData && gameStateData.attributes) {
                    const attrs = gameStateData.attributes;
                    
                    currentGameData = {
                        word_length: attrs.word_length || 5,
                        game_state: gameStateData.state || 'idle',
                        guesses: attrs.guess_history || [],
                        guess_results: attrs.guess_results || [],
                        hint: attrs.hint || '',
                        last_message: attrs.last_message || '',
                        message_type: attrs.message_type || 'info'
                    };
                    
                    diagLog(`Parsed Game Data: ${JSON.stringify(currentGameData, null, 2)}`, 'success');
                    
                    // Update UI
                    diagnosticUpdateUI();
                } else {
                    diagLog('No game state attributes found!', 'error');
                }
                
                return true;
                
            } catch (error) {
                diagLog(`Game state refresh failed: ${error.message}`, 'error');
                return false;
            }
        }

        // üîç DIAGNOSTIC UI UPDATE
        function diagnosticUpdateUI() {
            diagLog('=== UPDATING UI ===');
            
            // Update status
            const statusEl = document.getElementById('gameStatus');
            const statusText = `${currentGameData.game_state} | ${currentGameData.word_length} letters | ${currentGameData.guesses.length} guesses`;
            statusEl.textContent = statusText;
            diagLog(`Status updated: ${statusText}`);
            
            // Update grid
            diagnosticUpdateGrid();
            
            // Update hint
            const hintEl = document.getElementById('hintText');
            hintEl.textContent = currentGameData.hint || 'üîß No hint available';
            diagLog(`Hint updated: ${currentGameData.hint}`);
            
            // Update debug info
            updateDebugInfo();
        }

        // üîç DIAGNOSTIC GRID UPDATE
        function diagnosticUpdateGrid() {
            diagLog(`=== UPDATING GRID ===`);
            diagLog(`Grid update - Guesses: ${JSON.stringify(currentGameData.guesses)}`);
            diagLog(`Grid update - Results: ${JSON.stringify(currentGameData.guess_results)}`);
            
            // Ensure grid exists
            diagnosticCreateGrid(currentGameData.word_length);
            
            // Clear all tiles
            let tileCount = 0;
            gameGrid.forEach(row => {
                row.forEach(tile => {
                    tile.textContent = '';
                    tile.className = 'game-tile';
                    tileCount++;
                });
            });
            diagLog(`Cleared ${tileCount} tiles`);
            
            // Populate with guesses
            let populatedTiles = 0;
            currentGameData.guesses.forEach((guess, guessIndex) => {
                diagLog(`Processing guess ${guessIndex}: "${guess}"`);
                const result = currentGameData.guess_results[guessIndex] || [];
                
                for (let i = 0; i < guess.length; i++) {
                    if (gameGrid[guessIndex] && gameGrid[guessIndex][i]) {
                        const tile = gameGrid[guessIndex][i];
                        tile.textContent = guess[i];
                        tile.classList.add('filled');
                        
                        if (result[i]) {
                            tile.classList.add(result[i]);
                            diagLog(`Tile [${guessIndex}][${i}]: "${guess[i]}" -> ${result[i]}`);
                        }
                        populatedTiles++;
                    }
                }
            });
            
            diagLog(`Populated ${populatedTiles} tiles with guess data`, 'success');
        }

        // üîç DIAGNOSTIC GRID CREATION
        function diagnosticCreateGrid(wordLength) {
            if (wordLength === currentWordLength && gameGrid.length > 0) {
                diagLog(`Grid already exists for length ${wordLength}`);
                return;
            }
            
            diagLog(`Creating new ${wordLength}x${wordLength} grid`);
            currentWordLength = wordLength;
            const grid = document.getElementById('gameGrid');
            grid.innerHTML = '';
            
            grid.style.gridTemplateColumns = `repeat(${wordLength}, 1fr)`;
            grid.style.gridTemplateRows = `repeat(${wordLength}, 1fr)`;
            
            gameGrid = [];
            let totalTiles = 0;
            for (let row = 0; row < wordLength; row++) {
                gameGrid[row] = [];
                for (let col = 0; col < wordLength; col++) {
                    const tile = document.createElement('div');
                    tile.className = 'game-tile';
                    tile.dataset.row = row;
                    tile.dataset.col = col;
                    grid.appendChild(tile);
                    gameGrid[row][col] = tile;
                    totalTiles++;
                }
            }
            
            diagLog(`Grid created: ${totalTiles} tiles`, 'success');
        }

        // üîç DIAGNOSTIC ACTION HANDLER
        async function diagnosticAction(action, param = null) {
            actionCount++;
            diagLog(`=== ACTION ${actionCount}: ${action.toUpperCase()} ===`);
            
            try {
                if (action === 'newGame') {
                    diagLog('Calling ha_wordplay.new_game service...');
                    await diagnosticApiCall('/api/services/ha_wordplay/new_game', {
                        method: 'POST',
                        body: { word_length: currentWordLength }
                    });
                    diagLog('New game service call successful', 'success');
                    
                } else if (action === 'submit') {
                    const input = document.getElementById('guessInput');
                    const guess = input.value.trim().toUpperCase();
                    diagLog(`Submit action - guess: "${guess}"`);
                    
                    if (guess.length !== currentWordLength) {
                        diagLog(`Invalid guess length: ${guess.length} (expected ${currentWordLength})`, 'error');
                        return;
                    }
                    
                    // Two-step submit
                    diagLog('Step 1: Setting input entity...');
                    await diagnosticApiCall('/api/services/text/set_value', {
                        method: 'POST',
                        body: {
                            entity_id: 'text.ha_wordplay_guess_input',
                            value: guess
                        }
                    });
                    
                    diagLog('Step 2: Calling submit_guess service...');
                    await diagnosticApiCall('/api/services/ha_wordplay/submit_guess', {
                        method: 'POST',
                        body: {}
                    });
                    
                    diagLog('Submit action completed', 'success');
                    input.value = '';
                    
                } else if (action === 'hint') {
                    diagLog('Calling ha_wordplay.get_hint service...');
                    await diagnosticApiCall('/api/services/ha_wordplay/get_hint', {
                        method: 'POST',
                        body: {}
                    });
                    diagLog('Get hint service call successful', 'success');
                    
                } else if (action === 'changeLength') {
                    diagLog(`Changing word length to ${param}...`);
                    await diagnosticApiCall('/api/services/select/select_option', {
                        method: 'POST',
                        body: {
                            entity_id: 'select.ha_wordplay_word_length',
                            option: param.toString()
                        }
                    });
                    diagLog(`Word length changed to ${param}`, 'success');
                }
                
                // Refresh state after action
                setTimeout(async () => {
                    diagLog('Post-action state refresh...');
                    await diagnosticRefreshGameState();
                }, 1000);
                
            } catch (error) {
                diagLog(`Action ${action} failed: ${error.message}`, 'error');
            }
        }

        // üîç DIAGNOSTIC INPUT HANDLERS
        function diagnosticInput() {
            const input = document.getElementById('guessInput');
            diagLog(`Input changed: "${input.value}"`);
        }

        function diagnosticKeyPress(event) {
            if (event.key === 'Enter') {
                diagLog('Enter key pressed - triggering submit');
                event.preventDefault();
                diagnosticAction('submit');
            }
        }

        // üîç UPDATE DEBUG INFO
        function updateDebugInfo() {
            const debugEl = document.getElementById('debugInfo');
            debugEl.innerHTML = `
                Auth: ${authMethod}<br>
                Actions: ${actionCount}<br>
                Game State: ${currentGameData.game_state}<br>
                Word Length: ${currentGameData.word_length}<br>
                Guesses: ${currentGameData.guesses.length}<br>
                Last Entity Check: ${new Date().toLocaleTimeString()}
            `;
        }

        // üîç INITIALIZE DIAGNOSTIC MODE
        async function initDiagnostic() {
            diagLog('=== INITIALIZING DIAGNOSTIC MODE ===');
            
            accessToken = getAccessToken();
            
            // Create initial grid
            diagnosticCreateGrid(5);
            
            // Test connection
            try {
                await diagnosticRefreshGameState();
                document.getElementById('connectionStatus').textContent = '‚úÖ DIAGNOSTIC - Connected';
                document.getElementById('connectionStatus').className = 'connection-status';
            } catch (error) {
                document.getElementById('connectionStatus').textContent = '‚ùå DIAGNOSTIC - Connection Failed';
                document.getElementById('connectionStatus').className = 'connection-status disconnected';
            }
            
            // Start polling
            setInterval(async () => {
                diagLog('Auto-refresh triggered...');
                await diagnosticRefreshGameState();
            }, 5000);
            
            diagLog('Diagnostic mode initialization complete', 'success');
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üîß WordPlay DIAGNOSTIC MODE starting...');
            initDiagnostic();
        });

        // Debug interface
        window.diagnosticDebug = {
            refreshState: diagnosticRefreshGameState,
            getLastEntityData: () => lastEntityData,
            getCurrentGameData: () => currentGameData,
            clearLog: () => {
                diagnosticLog = [];
                updateDiagnosticDisplay();
            },
            testAction: (action, param) => diagnosticAction(action, param)
        };
    </script>
</body>
</html>